В FirstSolution я показал самый простой пример уменьшения cyclomatic complexity.
Применил сл. приемы:
Избавление от else
Избавление от лишних if блоков
cyclomatic complexity before: 9
cyclomatic complexity after: 3

В классе SecondTask хранится пример метода с большой цикломатической сложностью, решение задачи в классе SecondSolution.

SecondSolution:
Табличная логика:
Все boolean значение превратил в enum. На мой взгляд наличие boolean значений в бизнес коде требует вдумчивости и целесо-
образности т.к., как правило, их можно заменить на расширяемый енам. Практика показывает что булеан типы в бизнес моделях
 порождают со временм океан других булеан типов.
На основе енамов далее строится работа всех стратегий (провайдеров) и стратегий внутри них (провайдеров)

Полиморфизм:
В абстрактном классе сделал базовые обработчики для типонезависимого функционала, но организовал код таким образом,
чтобы в случае надобности нужды обработчик можно было бы добавить в дочернем классе и он перезатрет дефолтную реализацию
суперкласса

Также:
- избавился от лишних else блоков
- избавился от лишних if блоков

cyclomatic complexity before: 13
cyclomatic complexity after: 1 + x, где x - количество типов продуктов, из примера x = 2

имхо: код можно сделать более гибки, но основная задача выполнена + сделан задел на будущее масштабирование (сделал его легким)