Я взял за основу обычный http клиент, который запрашивает данные по id пользователя.
Если следовать tdd, то клиент должен выполнять следующие тесты/реализовывать следующие фичи:
Формирование запроса
Отправка запроса
Десериализация ответа
Валидация ответа

Тесты получаются вида:


void shouldBuildRequest()
void shouldRequestData()
void shouldDeserializeResponse()
void shouldValidate()

Согласно описанным тестам получается класс с методами:

DataRequest buildRequest(String var1, String var2)
JsonNode requestData(DataRequest request)
DataResponse deserializeResponse(JsonNode responseNode)
List<ConstraintViolation> validate(DataResponse response)

// По сути этот метод мы и будем вызывать на клиенте, остальные методы больше служебные
DataResponse sendRequest(String var, String var2)

Тесты пишутся на каждый метод, проверяя корректность работы, пограничные случаи итд
С точки зрения tdd все сделано правильно, но как бы не так.
Если рассматривать клиент с т.з. дизайна, то класс будет выглядить примерно так:

class DataClient {
  private RequestBuilder requestBuilder;
  private RestTemplate restTemplate;
  private ObjectMapper objectMapper;
  private Validator validator;
}

Задача и ответственность клиента сужается до правильного использования зависимостей, ответственных за тот
или иной кусок ф-ла/обработке ошибок(хотя и это можно вырезать используя прокси-подход)/ретраи(тоже можно
вырезать используя прокси-подход).
Для тестирования теперь нет необходимости раздувать тесты конфигурируя большой контекст, а можно, к примеру,
использовать библиотечку Mockito или аналоги для тестирования количества/качества вызовов методов зависимостей.

Профит НЕиспользования tdd в лоб заключается в:
- Соблюдении принципа single responsibility
- Возможности выстраивания правильного дизайна классов, а следовательно более модульному тестированию
- Отсутствия зависимости компонентов от конкретных реализаций их зависимостей, при правильном проектировании
нам не важна та или иная реализация зависимости, мы лишь проверяем ее вызовы и правильность аргументов в этих вызовах,
а сами зависимости, если их написали мы, также реализуем по принципу tdd, но с упором на дизайн классов,
а не на фичи, которые должен этот компонент реализовывать