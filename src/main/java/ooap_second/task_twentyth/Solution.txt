1) Наследование вариаций:
Возьмем классический маппер, который умеет преобразовывать из объекта класса A, в класс Б. Однако представим
что объекты класса А различаются по, к примеру, типу источника схожи по структуре, хранятся в виде single table,
но логика их заполнения зависит именно от дескриминатора (поля-источника). В таком случае мы можем мы можем задать
базовое поведение маппинга (для составных данных непримитивных типов) в родительском классе, а в случае когда реализа-
ция этого маппинга будет различаться в непосредственном маппере какого-то определенного источника - этот класс будет
определять свою реализацию маппинга. Таким образом собрать объект класса Б мы можем вызывая базовые/переопределенные
методы суперкласса/классов-наследников в суперклассе и оставить классам-наследникам ответственность лишь реализовать/
оставить дефолтной маппинг тех или иных полей класса А.

2) Наследование с конкретизацией:
Например игра в шахматы: все фигуры имеют какое-то поведение (отрисовать себя, вернуть возможные ходы, походить),
но непосредственная реализация будет уже в классах-наследниках

3) Структурное наследование:
Например мы пишем онлайн-игру и у нас есть АТД NPC. Этот NPC должен в зависимости от реализации:
- говорить
- продавать
- атаковать
- ходить
- летать

Способности атаковать, ходить и летать можно реализовать используя структурное наследование, благодаря чему потом
с помощью полиморфизма использовать всех npc/мобов/существ для этих действий. Например в случае тревоги в каком-то
районе все существа кто умеет атаковать - будут атаковать угрозу, а чтобы ее атаковать каждый будет либо бежать, либо лететь.